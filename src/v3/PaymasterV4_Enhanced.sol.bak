// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import { PackedUserOperation } from "@account-abstraction-v7/interfaces/PackedUserOperation.sol";
import { _packValidationData } from "@account-abstraction-v7/core/Helpers.sol";
import { UserOperationLib } from "@account-abstraction-v7/core/UserOperationLib.sol";
import { IEntryPoint } from "@account-abstraction-v7/interfaces/IEntryPoint.sol";

import { Ownable } from "@openzeppelin-v5.0.2/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin-v5.0.2/contracts/utils/ReentrancyGuard.sol";
import { IERC20 } from "@openzeppelin-v5.0.2/contracts/token/ERC20/IERC20.sol";

import { ISBT } from "../interfaces/ISBT.sol";
import { PostOpMode } from "../../singleton-paymaster/src/interfaces/PostOpMode.sol";

using UserOperationLib for PackedUserOperation;

/// @title PaymasterV4_Enhanced
/// @notice Direct transfer mode with cross-chain support - no Settlement, no PostOp recording
/// @dev Supports both Ethereum Mainnet and OP Mainnet with chain-specific configurations
/// @dev Charges chain-specific premium over estimated gas cost as service fee
/// @dev No refund in PostOp - simplified and gas-efficient (saves ~254k gas vs V3)
/// @custom:security-contact security@aastar.community
contract PaymasterV4_Enhanced is Ownable, ReentrancyGuard {
    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                  CONSTANTS AND IMMUTABLES                  */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @notice EntryPoint contract address (immutable for security)
    IEntryPoint public immutable entryPoint;

    /// @notice Chain ID for this deployment
    uint256 public immutable chainId;

    /// @notice Paymaster data offset in paymasterAndData
    uint256 private constant PAYMASTER_DATA_OFFSET = 52;

    /// @notice Minimum paymasterAndData length
    uint256 private constant MIN_PAYMASTER_AND_DATA_LENGTH = 52;

    /// @notice Contract version
    string public constant VERSION = "PaymasterV4-Enhanced-v1.0.0";

    /// @notice Basis points denominator
    uint256 private constant BPS_DENOMINATOR = 10000;

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                      STRUCTS                               */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @notice Chain-specific configuration
    struct ChainConfig {
        uint256 pntToEthRate;    // PNT to ETH exchange rate (18 decimals precision)
        uint256 serviceFee;      // Service fee in basis points (e.g., 200 = 2%)
        uint256 maxGasCostCap;   // Maximum gas cost per operation (in wei)
        bool enabled;            // Whether this chain is enabled
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                          STORAGE                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @notice Soul-Bound Token contract for user qualification
    address public sbtContract;

    /// @notice ERC20 token used for gas payment (PNT)
    address public gasToken;

    /// @notice Minimum token balance required for qualification
    uint256 public minTokenBalance;

    /// @notice Emergency pause flag
    bool public paused;

    /// @notice Chain-specific configurations
    mapping(uint256 => ChainConfig) public chainConfigs;

    /// @notice Optional price feed for dynamic rates (e.g., Chainlink)
    address public priceFeed;

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                       CUSTOM ERRORS                        */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    error PaymasterV4__OnlyEntryPoint();
    error PaymasterV4__Paused();
    error PaymasterV4__ZeroAddress();
    error PaymasterV4__InvalidTokenBalance();
    error PaymasterV4__NoSBT();
    error PaymasterV4__InsufficientPNT();
    error PaymasterV4__InvalidPaymasterData();
    error PaymasterV4__TransferFailed();
    error PaymasterV4__InvalidRate();
    error PaymasterV4__ChainNotEnabled();
    error PaymasterV4__InvalidServiceFee();

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           EVENTS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    event GasSponsored(
        address indexed user,
        uint256 maxCost,
        uint256 cappedCost,
        address indexed token,
        uint256 indexed chainId
    );

    event DirectPayment(
        address indexed user,
        uint256 pntAmount,
        uint256 estimatedGasCost,
        uint256 serviceFee,
        uint256 indexed chainId
    );

    event ChainConfigUpdated(
        uint256 indexed chainId,
        uint256 pntToEthRate,
        uint256 serviceFee,
        uint256 maxGasCostCap,
        bool enabled
    );

    event Paused(address indexed account);
    event Unpaused(address indexed account);
    event SBTContractUpdated(address indexed oldSBT, address indexed newSBT);
    event GasTokenUpdated(address indexed oldToken, address indexed newToken);
    event MinTokenBalanceUpdated(uint256 oldBalance, uint256 newBalance);
    event PriceFeedUpdated(address indexed oldFeed, address indexed newFeed);

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                        MODIFIERS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    modifier onlyEntryPoint() {
        if (msg.sender != address(entryPoint)) {
            revert PaymasterV4__OnlyEntryPoint();
        }
        _;
    }

    modifier whenNotPaused() {
        if (paused) {
            revert PaymasterV4__Paused();
        }
        _;
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                        CONSTRUCTOR                         */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    constructor(
        address _entryPoint,
        address _sbtContract,
        address _gasToken,
        uint256 _minTokenBalance,
        uint256 _chainId
    ) Ownable(msg.sender) {
        if (_entryPoint == address(0)) revert PaymasterV4__ZeroAddress();
        if (_sbtContract == address(0)) revert PaymasterV4__ZeroAddress();
        if (_gasToken == address(0)) revert PaymasterV4__ZeroAddress();
        if (_minTokenBalance == 0) revert PaymasterV4__InvalidTokenBalance();

        entryPoint = IEntryPoint(_entryPoint);
        sbtContract = _sbtContract;
        gasToken = _gasToken;
        minTokenBalance = _minTokenBalance;
        chainId = _chainId;
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                    ENTRYPOINT FUNCTIONS                    */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @notice Validates paymaster operation and charges user upfront
    /// @dev Direct transfer mode: charges chain-specific premium, no refund in postOp
    /// @param userOp The user operation
    /// @param maxCost Maximum cost for this userOp (in wei)
    /// @return context Empty context (not used in V4)
    /// @return validationData Always returns 0 (success) or reverts
    function validatePaymasterUserOp(
        PackedUserOperation calldata userOp,
        bytes32 /* userOpHash */,
        uint256 maxCost
    )
        external
        onlyEntryPoint
        whenNotPaused
        nonReentrant
        returns (bytes memory context, uint256 validationData)
    {
        // Validate paymasterAndData length
        if (userOp.paymasterAndData.length < MIN_PAYMASTER_AND_DATA_LENGTH) {
            revert PaymasterV4__InvalidPaymasterData();
        }

        // Get chain config
        ChainConfig memory config = chainConfigs[chainId];
        if (!config.enabled) {
            revert PaymasterV4__ChainNotEnabled();
        }

        address sender = userOp.getSender();

        // Check 1: User must own at least one SBT
        uint256 sbtBalance = ISBT(sbtContract).balanceOf(sender);
        if (sbtBalance == 0) {
            revert PaymasterV4__NoSBT();
        }

        // Check 2: User must have sufficient PNT balance (minimum requirement)
        uint256 pntBalance = IERC20(gasToken).balanceOf(sender);
        if (pntBalance < minTokenBalance) {
            revert PaymasterV4__InsufficientPNT();
        }

        // Apply gas cost cap to prevent overpayment
        uint256 cappedMaxCost = _validateAndCapGasCost(maxCost, config);

        // Calculate PNT amount with chain-specific service fee
        // Formula: PNT = (gasCost_wei * pntToEthRate / 1e18) * (1 + serviceFee_bps / 10000)
        uint256 pntAmount = _calculatePNTAmount(cappedMaxCost, config);

        // Check 3: User must have enough PNT for this specific operation
        if (pntBalance < pntAmount) {
            revert PaymasterV4__InsufficientPNT();
        }

        // Direct transfer: User pays now, no refund later
        bool success = IERC20(gasToken).transferFrom(sender, address(this), pntAmount);
        if (!success) {
            revert PaymasterV4__TransferFailed();
        }

        // Emit events for tracking
        emit DirectPayment(sender, pntAmount, cappedMaxCost, config.serviceFee, chainId);
        emit GasSponsored(sender, maxCost, cappedMaxCost, gasToken, chainId);

        // Return empty context (postOp does nothing in V4)
        context = "";
        validationData = 0;
    }

    /// @notice Post-operation handler (does nothing in V4)
    /// @dev No refund, no recording - payment already handled in validation
    /// @dev This saves ~254k gas compared to V3's postOp
    function postOp(
        PostOpMode /* mode */,
        bytes calldata /* context */,
        uint256 /* actualGasCost */,
        uint256 /* actualUserOpFeePerGas */
    )
        external
        onlyEntryPoint
    {
        // V4 Enhanced: No postOp logic needed
        // User already paid with chain-specific premium in validatePaymasterUserOp
        // The premium covers:
        // - Gas price fluctuations
        // - PostOp execution cost (minimal now)
        // - Paymaster service fee
        //
        // Gas savings vs V3: ~254k gas (86% reduction)
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                    INTERNAL FUNCTIONS                      */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @notice Validate and cap the gas cost
    /// @param maxCost Original maxCost from EntryPoint
    /// @param config Chain configuration
    /// @return Capped maxCost
    function _validateAndCapGasCost(
        uint256 maxCost,
        ChainConfig memory config
    ) internal pure returns (uint256) {
        // If maxCost exceeds cap, use cap to protect user
        if (maxCost > config.maxGasCostCap) {
            return config.maxGasCostCap;
        }
        return maxCost;
    }

    /// @notice Calculate PNT amount needed for gas cost
    /// @param gasCost Gas cost in wei (after capping)
    /// @param config Chain configuration
    /// @return PNT amount needed
    function _calculatePNTAmount(
        uint256 gasCost,
        ChainConfig memory config
    ) internal pure returns (uint256) {
        // Convert wei to PNT: gasCost * rate / 1e18
        uint256 basePNT = (gasCost * config.pntToEthRate) / 1e18;

        // Add service fee: basePNT * (1 + fee/10000)
        uint256 totalPNT = (basePNT * (BPS_DENOMINATOR + config.serviceFee)) / BPS_DENOMINATOR;

        return totalPNT;
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                      ADMIN FUNCTIONS                       */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @notice Update chain configuration
    /// @param _chainId Chain ID to configure
    /// @param _pntToEthRate PNT to ETH rate (18 decimals, e.g., 50e18 = 50 PNT per ETH)
    /// @param _serviceFee Service fee in basis points (e.g., 200 = 2%)
    /// @param _maxGasCostCap Maximum gas cost cap in wei
    /// @param _enabled Whether to enable this chain
    function updateChainConfig(
        uint256 _chainId,
        uint256 _pntToEthRate,
        uint256 _serviceFee,
        uint256 _maxGasCostCap,
        bool _enabled
    ) external onlyOwner {
        if (_pntToEthRate == 0) revert PaymasterV4__InvalidRate();
        if (_serviceFee > 1000) revert PaymasterV4__InvalidServiceFee(); // Max 10%

        chainConfigs[_chainId] = ChainConfig({
            pntToEthRate: _pntToEthRate,
            serviceFee: _serviceFee,
            maxGasCostCap: _maxGasCostCap,
            enabled: _enabled
        });

        emit ChainConfigUpdated(_chainId, _pntToEthRate, _serviceFee, _maxGasCostCap, _enabled);
    }

    /// @notice Update SBT contract address
    function setSBTContract(address _sbtContract) external onlyOwner {
        if (_sbtContract == address(0)) revert PaymasterV4__ZeroAddress();

        address oldSBT = sbtContract;
        sbtContract = _sbtContract;

        emit SBTContractUpdated(oldSBT, _sbtContract);
    }

    /// @notice Update gas token address
    function setGasToken(address _gasToken) external onlyOwner {
        if (_gasToken == address(0)) revert PaymasterV4__ZeroAddress();

        address oldToken = gasToken;
        gasToken = _gasToken;

        emit GasTokenUpdated(oldToken, _gasToken);
    }

    /// @notice Update minimum token balance requirement
    function setMinTokenBalance(uint256 _minTokenBalance) external onlyOwner {
        if (_minTokenBalance == 0) revert PaymasterV4__InvalidTokenBalance();

        uint256 oldBalance = minTokenBalance;
        minTokenBalance = _minTokenBalance;

        emit MinTokenBalanceUpdated(oldBalance, _minTokenBalance);
    }

    /// @notice Update price feed address (optional, for future Oracle integration)
    function setPriceFeed(address _priceFeed) external onlyOwner {
        address oldFeed = priceFeed;
        priceFeed = _priceFeed;

        emit PriceFeedUpdated(oldFeed, _priceFeed);
    }

    /// @notice Pause the paymaster
    function pause() external onlyOwner {
        paused = true;
        emit Paused(msg.sender);
    }

    /// @notice Unpause the paymaster
    function unpause() external onlyOwner {
        paused = false;
        emit Unpaused(msg.sender);
    }

    /// @notice Withdraw accumulated PNT tokens
    /// @param to Recipient address
    /// @param amount Amount to withdraw
    function withdrawPNT(address to, uint256 amount) external onlyOwner {
        if (to == address(0)) revert PaymasterV4__ZeroAddress();

        bool success = IERC20(gasToken).transfer(to, amount);
        if (!success) revert PaymasterV4__TransferFailed();
    }

    /// @notice Add stake to EntryPoint
    /// @param unstakeDelaySec Unstake delay in seconds
    function addStake(uint32 unstakeDelaySec) external payable onlyOwner {
        entryPoint.addStake{value: msg.value}(unstakeDelaySec);
    }

    /// @notice Unlock stake from EntryPoint
    function unlockStake() external onlyOwner {
        entryPoint.unlockStake();
    }

    /// @notice Withdraw stake from EntryPoint
    /// @param withdrawAddress Address to receive stake
    function withdrawStake(address payable withdrawAddress) external onlyOwner {
        entryPoint.withdrawStake(withdrawAddress);
    }

    /// @notice Deposit ETH to EntryPoint
    function deposit() external payable onlyOwner {
        entryPoint.depositTo{value: msg.value}(address(this));
    }

    /// @notice Withdraw ETH from EntryPoint
    /// @param withdrawAddress Address to receive ETH
    /// @param amount Amount to withdraw
    function withdrawTo(address payable withdrawAddress, uint256 amount) external onlyOwner {
        entryPoint.withdrawTo(withdrawAddress, amount);
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                      VIEW FUNCTIONS                        */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @notice Get deposit info from EntryPoint
    function getDeposit() external view returns (uint256) {
        return entryPoint.getDepositInfo(address(this)).deposit;
    }

    /// @notice Get configuration for a specific chain
    function getChainConfig(uint256 _chainId) external view returns (ChainConfig memory) {
        return chainConfigs[_chainId];
    }

    /// @notice Calculate how much PNT is needed for a given gas cost on this chain
    /// @param gasCost Gas cost in wei
    /// @return PNT amount needed
    function estimatePNTCost(uint256 gasCost) external view returns (uint256) {
        ChainConfig memory config = chainConfigs[chainId];
        uint256 cappedCost = _validateAndCapGasCost(gasCost, config);
        return _calculatePNTAmount(cappedCost, config);
    }

    /// @notice Check if user is qualified for gas sponsorship
    /// @param user User address
    /// @param estimatedGasCost Estimated gas cost in wei
    /// @return qualified Whether user qualifies
    /// @return reason Reason if not qualified
    function checkUserQualification(
        address user,
        uint256 estimatedGasCost
    ) external view returns (bool qualified, string memory reason) {
        // Check SBT
        if (ISBT(sbtContract).balanceOf(user) == 0) {
            return (false, "No SBT");
        }

        // Check minimum PNT balance
        uint256 pntBalance = IERC20(gasToken).balanceOf(user);
        if (pntBalance < minTokenBalance) {
            return (false, "Insufficient minimum PNT balance");
        }

        // Check PNT for this operation
        ChainConfig memory config = chainConfigs[chainId];
        uint256 cappedCost = _validateAndCapGasCost(estimatedGasCost, config);
        uint256 pntNeeded = _calculatePNTAmount(cappedCost, config);

        if (pntBalance < pntNeeded) {
            return (false, "Insufficient PNT for this operation");
        }

        return (true, "");
    }

    /// @notice Receive ETH
    receive() external payable {}
}
