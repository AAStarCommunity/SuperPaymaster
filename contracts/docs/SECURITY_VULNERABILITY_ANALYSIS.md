# V3 å®‰å…¨æ¼æ´åˆ†æä¸ä¿®å¤æ–¹æ¡ˆ

**æ—¥æœŸ**: 2025-11-28
**ä¸¥é‡çº§åˆ«**: ğŸ”´ HIGH
**çŠ¶æ€**: å¾…ä¿®å¤

---

## ğŸ”´ å…³é”®æ¼æ´: Unstake å¯¼è‡´æ— è´¨æŠ¼çš„æ´»è·ƒ Role

### æ¼æ´æè¿°

**é—®é¢˜**: ç”¨æˆ·å¯ä»¥åœ¨ä¿æŒæ´»è·ƒ role çš„åŒæ—¶å®Œå…¨ unstakeï¼Œå¯¼è‡´ï¼š
1. âŒ **æ— æ³• slash** - æ²¡æœ‰è´¨æŠ¼å¯ä»¥æƒ©ç½š
2. âŒ **å¥³å·«æ”»å‡»** - é›¶æˆæœ¬åˆ›å»ºå¤šä¸ªæ¶æ„ role
3. âŒ **ç³»ç»Ÿå¤±ä¿¡** - stake ä½œä¸ºæ‹…ä¿çš„æœºåˆ¶å¤±æ•ˆ

### æ”»å‡»åœºæ™¯

```javascript
// æ”»å‡»è€…æµç¨‹
// 1. æ³¨å†Œä¸º Paymaster (é”å®š 1000 GToken)
await gtoken.approve(staking, 1000e18);
await staking.stake(1000e18);
await registry.registerRole(ROLE_PAYMASTER, attacker, data);
// â†’ staking.lockStake(attacker, ROLE_PAYMASTER, 1000e18)
// â†’ ç°åœ¨ locked: 1000e18, available: 0

// 2. å†æ¬¡ stake é¢å¤–èµ„é‡‘ (ç»•è¿‡é”å®š)
await gtoken.approve(staking, 100e18);
await staking.stake(100e18);
// â†’ ç°åœ¨ locked: 1000e18, available: 100e18

// 3. ç«‹å³ unstake available balance âŒ æ¼æ´!
await staking.requestUnstake(100 shares);
await staking.completeUnstake();  // å–å› 100e18
// â†’ ç°åœ¨ locked: 1000e18, available: 0

// 4. ç»§ç»­ unstake ç›´åˆ° available > locked
await gtoken.approve(staking, 10000e18);
await staking.stake(10000e18);
// â†’ locked: 1000e18, available: 10000e18

await staking.requestUnstake(all shares);
await staking.completeUnstake();
// â†’ locked: 1000e18, available: 0, ä½†å–å›äº† 10000e18!

// 5. æ”»å‡»è€…ç°åœ¨å¯ä»¥:
// - ä½œä¸º Paymaster ä½œæ¶
// - æ— æ³•è¢« slash (åªæœ‰ 1000e18 lockedï¼Œä½†å·²ç»æå–åˆ©æ¶¦)
// - åˆ›å»ºæ— æ•°ä¸ªè¿™æ ·çš„ Paymaster (å¥³å·«æ”»å‡»)
```

### å½“å‰å®ç°é—®é¢˜

```solidity
// GTokenStaking - requestUnstake()
function requestUnstake(uint256 shares) external {
    // âŒ æ²¡æœ‰æ£€æŸ¥ locked balance!
    // å…è®¸ç”¨æˆ· unstake å³ä½¿ä»–ä»¬æœ‰æ´»è·ƒçš„ role locks

    stakes[msg.sender].unstakeRequestedAt = block.timestamp;
    // ...
}

// GTokenStaking - completeUnstake()
function completeUnstake() external returns (uint256 amount) {
    // âŒ æ²¡æœ‰æ£€æŸ¥æ˜¯å¦ä¼šå¯¼è‡´ available < locked!
    uint256 shares = stakes[msg.sender].shares;
    amount = convertToAssets(shares);

    // Transfer tokens back
    gtoken.transfer(msg.sender, amount);
    // ...
}
```

---

## ğŸ›¡ï¸ ä¿®å¤æ–¹æ¡ˆ

### æ–¹æ¡ˆ A: ç¦æ­¢ Unstake å¦‚æœæœ‰æ´»è·ƒ Locks (æ¨è)

**åŸåˆ™**: ç”¨æˆ·å¿…é¡»å…ˆ `exitRole()` æ‰èƒ½ `unstake`

```solidity
// IGTokenStakingV3.sol
interface IGTokenStakingV3 {
    // âŒ REMOVE: Direct user unstake
    // function requestUnstake(uint256 shares) external;
    // function completeUnstake() external returns (uint256);

    // âœ… ADD: Only Registry can unlock
    function unlockStake(address user, bytes32 roleId)
        external
        onlyRegistry
        returns (uint256 netAmount);

    // âœ… ADD: User can unstake only AFTER all roles exited
    function requestUnstakeAll() external;  // åªæœ‰å½“ totalLocked == 0 æ—¶å…è®¸
}
```

**å®ç°**:

```solidity
// GTokenStaking_v3.sol
function requestUnstakeAll() external {
    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰ä»»ä½•æ´»è·ƒçš„ role locks
    uint256 totalLocked = _getTotalLockedForUser(msg.sender);
    if (totalLocked > 0) {
        revert CannotUnstakeWithActiveLocks(totalLocked);
    }

    // å…è®¸ unstake å…¨éƒ¨ available balance
    stakes[msg.sender].unstakeRequestedAt = block.timestamp;
}

function _getTotalLockedForUser(address user) internal view returns (uint256 total) {
    RoleLock[] memory locks = userRoleLocks[user];
    for (uint256 i = 0; i < locks.length; i++) {
        total += locks[i].amount;
    }
}
```

**ç”¨æˆ·æµç¨‹**:

```javascript
// æ­£ç¡®æµç¨‹
// 1. Register role
await registry.registerRole(ROLE_PAYMASTER, user, data);
// â†’ staking.lockStake() é”å®š 1000e18

// 2. å¦‚æœæƒ³é€€å‡ºï¼Œå¿…é¡»å…ˆ exitRole
await registry.exitRole(ROLE_PAYMASTER);
// â†’ staking.unlockStake() è§£é”å¹¶æ‰£é™¤ exit fee

// 3. ç°åœ¨æ‰èƒ½ unstake
await staking.requestUnstakeAll();  // âœ… å…è®¸ (totalLocked == 0)
await staking.completeUnstake();
```

### æ–¹æ¡ˆ B: é™åˆ¶ Unstake é¢åº¦ (å¤‡é€‰)

**åŸåˆ™**: å…è®¸éƒ¨åˆ† unstakeï¼Œä½†å¿…é¡»ä¿æŒ `available >= locked`

```solidity
function requestUnstake(uint256 shares) external {
    uint256 totalLocked = _getTotalLockedForUser(msg.sender);
    uint256 currentAvailable = availableBalance(msg.sender);
    uint256 amountToUnstake = convertToAssets(shares);

    // ç¡®ä¿ unstake åä»æœ‰è¶³å¤Ÿ available balance è¦†ç›– locked
    if (currentAvailable - amountToUnstake < totalLocked) {
        revert InsufficientAvailableBalance(
            currentAvailable,
            totalLocked,
            amountToUnstake
        );
    }

    stakes[msg.sender].unstakeRequestedAt = block.timestamp;
    // ...
}
```

**é—®é¢˜**: å¤æ‚åº¦é«˜ï¼Œç”¨æˆ·ä½“éªŒå·®

### æ–¹æ¡ˆ C: ç§»é™¤ç‹¬ç«‹ Staking å‡½æ•° (æœ€ç®€å•)

**åŸåˆ™**: æ‰€æœ‰ stake/unstake éƒ½é€šè¿‡ Registry

```solidity
// âŒ REMOVE from IGTokenStakingV3
// function stake(uint256 amount) external;
// function requestUnstake(uint256 shares) external;

// âœ… ONLY keep Registry-called functions
function lockStake(address user, bytes32 roleId, uint256 amount, uint256 entryBurn)
    external
    onlyRegistry
    returns (uint256 lockId);

function unlockStake(address user, bytes32 roleId)
    external
    onlyRegistry
    returns (uint256 netAmount);
```

**Registry å®ç°è‡ªåŠ¨ stake**:

```solidity
// Registry_v3_0_0.sol
function registerRole(bytes32 roleId, address user, bytes calldata roleData) {
    // ... validation ...

    // âœ… Registry å†…éƒ¨è°ƒç”¨ staking.stakeFor()
    GTOKEN.safeTransferFrom(user, address(GTOKEN_STAKING), stakeAmount);
    GTOKEN_STAKING.stakeFor(user, stakeAmount);

    // âœ… ç«‹å³ lock for role
    GTOKEN_STAKING.lockStake(user, roleId, stakeAmount, config.entryBurn);
}

function exitRole(bytes32 roleId) {
    // âœ… Unlock and auto-unstake
    uint256 netAmount = GTOKEN_STAKING.unlockStake(msg.sender, roleId);

    // âœ… Auto-unstake å¹¶è¿”è¿˜ç”¨æˆ·
    GTOKEN_STAKING.unstakeAndTransfer(msg.sender, netAmount);
}
```

---

## ğŸ¯ æ¨èæ–¹æ¡ˆ: A + éƒ¨åˆ† C

### æ··åˆæ–¹æ¡ˆ

1. **ä¿ç•™ç‹¬ç«‹ stake()** - ç”¨æˆ·å¯ä»¥æå‰ stake èµšå–æ”¶ç›Š
2. **ç§»é™¤ requestUnstake()/completeUnstake()** - é˜²æ­¢ç»•è¿‡ lock
3. **åªå…è®¸é€šè¿‡ exitRole() unstake** - ç¡®ä¿éµå¾ªæµç¨‹

```solidity
// IGTokenStakingV3.sol (ä¿®æ”¹å)
interface IGTokenStakingV3 {
    // âœ… KEEP: User can stake to earn yield
    function stake(uint256 amount) external returns (uint256 shares);
    function stakeFor(address beneficiary, uint256 amount) external returns (uint256 shares);

    // âŒ REMOVE: Direct unstake (security risk)
    // function requestUnstake(uint256 shares) external;
    // function completeUnstake() external returns (uint256);

    // âœ… ADD: Only through Registry.exitRole()
    function unlockAndUnstake(address user, bytes32 roleId)
        external
        onlyRegistry
        returns (uint256 netAmount);
}
```

### å®ç°ç»†èŠ‚

```solidity
// GTokenStaking_v3.sol
function unlockAndUnstake(
    address user,
    bytes32 roleId
) external onlyRegistry returns (uint256 netAmount) {
    // 1. Unlock stake for role
    RoleLock memory lock = userRoleLocks[user][roleId];
    if (lock.amount == 0) revert NoLockFound(user, roleId);

    // 2. Calculate exit fee
    ExitFeeConfig memory feeConfig = roleExitFees[roleId];
    uint256 fee = (lock.amount * feeConfig.feePercent) / 10000;
    if (fee < feeConfig.minFee) fee = feeConfig.minFee;

    netAmount = lock.amount - fee;

    // 3. Delete lock
    delete userRoleLocks[user][roleId];

    // 4. Transfer exit fee to DAO
    if (fee > 0) {
        gtoken.transfer(daoAddress, fee);
    }

    // 5. Auto-unstake and return to user âœ… å…³é”®æ”¹åŠ¨
    // ä¸éœ€è¦ cooldownï¼Œç›´æ¥è¿”è¿˜
    gtoken.transfer(user, netAmount);

    emit StakeUnlockedAndUnstaked(user, roleId, lock.amount, fee, netAmount);
}
```

### Registry é…åˆä¿®æ”¹

```solidity
// Registry_v3_0_0.sol
function exitRole(bytes32 roleId) external nonReentrant {
    // ... validation ...

    // âœ… è°ƒç”¨æ–°å‡½æ•° unlockAndUnstake
    uint256 netAmount = GTOKEN_STAKING.unlockAndUnstake(msg.sender, roleId);

    // Burn tokens
    uint256 burnAmount = (netAmount * config.exitBurnPercent) / 10000;
    if (burnAmount > 0) {
        // Note: netAmount å·²ç»è½¬ç»™ userï¼Œéœ€è¦ä» user æ‰£é™¤
        GTOKEN.safeTransferFrom(msg.sender, BURN_ADDRESS, burnAmount);
    }

    // Record burn
    // ...
}
```

---

## ğŸ“Š æ–¹æ¡ˆå¯¹æ¯”

| æ–¹æ¡ˆ | å®‰å…¨æ€§ | ç”¨æˆ·ä½“éªŒ | å¤æ‚åº¦ | çµæ´»æ€§ | æ¨èåº¦ |
|------|--------|----------|--------|--------|--------|
| A: ç¦æ­¢ unstake with locks | â­â­â­â­â­ | â­â­â­ | â­â­â­ | â­â­â­ | â­â­â­â­ |
| B: é™åˆ¶ unstake é¢åº¦ | â­â­â­â­ | â­â­ | â­â­â­â­ | â­â­â­â­ | â­â­ |
| C: ç§»é™¤ç‹¬ç«‹ staking | â­â­â­â­â­ | â­â­ | â­â­â­â­â­ | â­â­ | â­â­â­ |
| **A+C æ··åˆ** | â­â­â­â­â­ | â­â­â­â­ | â­â­â­ | â­â­â­â­ | **â­â­â­â­â­** |

---

## ğŸ”§ å®æ–½æ­¥éª¤

### Step 1: ä¿®æ”¹ IGTokenStakingV3 æ¥å£

```solidity
interface IGTokenStakingV3 {
    // KEPT
    function stake(uint256 amount) external returns (uint256 shares);
    function stakeFor(address beneficiary, uint256 amount) external returns (uint256 shares);

    // REMOVED (security risk)
    // function requestUnstake(uint256 shares) external;
    // function completeUnstake() external returns (uint256);

    // ADDED
    function unlockAndUnstake(address user, bytes32 roleId)
        external
        onlyRegistry
        returns (uint256 netAmount);
}
```

### Step 2: æ›´æ–° Registry_v3_0_0.sol

```solidity
function exitRole(bytes32 roleId) external nonReentrant {
    // Change from unlockStake() to unlockAndUnstake()
    uint256 netAmount = GTOKEN_STAKING.unlockAndUnstake(msg.sender, roleId);
    // ... rest of logic ...
}
```

### Step 3: æ›´æ–°æ–‡æ¡£

- FUNCTION_MAP_V3.md: ç§»é™¤ requestUnstake/completeUnstake
- V3_DESIGN_ANALYSIS.md: æ·»åŠ å®‰å…¨ä¿®å¤è¯´æ˜
- README: æ›´æ–°ç”¨æˆ·æµç¨‹

---

## âœ… ä¿®å¤åçš„å®‰å…¨ä¿è¯

1. âœ… **æ— æ³•ç»•è¿‡ lock**: ç”¨æˆ·å¿…é¡» exitRole() æ‰èƒ½å–å› stake
2. âœ… **å¯ slash**: æ´»è·ƒ role å§‹ç»ˆæœ‰è¶³å¤Ÿè´¨æŠ¼
3. âœ… **é˜²å¥³å·«**: æ¯ä¸ª role éƒ½éœ€è¦çœŸå®çš„è´¨æŠ¼æˆæœ¬
4. âœ… **ç”¨æˆ·å‹å¥½**: ä»å¯æå‰ stake èµšå–æ”¶ç›Š
5. âœ… **ç®€åŒ–é€»è¾‘**: ç§»é™¤äº†å¤æ‚çš„ cooldown æœºåˆ¶

---

## ğŸ¯ ä¸‹ä¸€æ­¥

1. å®æ–½æ¥å£ä¿®æ”¹
2. æ›´æ–° Registry exitRole() é€»è¾‘
3. ç¼–å†™å®‰å…¨æµ‹è¯•ç”¨ä¾‹
4. æ›´æ–°æ‰€æœ‰æ–‡æ¡£

**ä¼˜å…ˆçº§**: ğŸ”´ HIGH - å¿…é¡»åœ¨ Phase 2 ä¸­ä¿®å¤
